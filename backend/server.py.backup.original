# backend/server.py - VERSÃO FINAL E CORRIGIDA

# ================================
# IMPORTS
# ================================
import sys
import os
import logging
from pathlib import Path
import json
import io
import csv
import base64
from datetime import datetime, timedelta
from enum import Enum
from typing import List, Optional, Dict, Any
import uuid

from dotenv import load_dotenv
from fastapi import FastAPI, APIRouter, HTTPException, Query, UploadFile, File, Depends, Request
from fastapi.responses import StreamingResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from starlette.middleware.cors import CORSMiddleware
from googleapiclient.discovery import build
from google.auth.transport.requests import Request as GoogleRequest
from google.oauth2 import service_account
from firebase_admin import firestore

# ✅ IMPORTAR SERVIÇOS DE PAGAMENTO
try:
    from services.paypal_service import paypal_service
    PAYPAL_AVAILABLE = paypal_service is not None
except ImportError:
    PAYPAL_AVAILABLE = False
    paypal_service = None

try:
    from services.stripe_service import stripe_service
    STRIPE_AVAILABLE = stripe_service is not None
except ImportError:
    STRIPE_AVAILABLE = False
    stripe_service = None

# ✅ IMPORTAR ROUTERS
from routers import tours_fixed as tours_router
from routers.seo_routes import setup_seo_routes

# Set up root directory and load environment variables
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# ================================
# ✅ FIREBASE INITIALIZATION - IMPORTAR DO CONFIG
# ================================
try:
    from config.firestore_db import db as db_firestore
    print("✅ Firebase importado do config centralizado")
except ImportError as e:
    print(f"❌ Erro ao importar config Firebase: {e}")
    sys.exit(1)

# ================================
# FASTAPI APP INITIALIZATION
# ================================
app = FastAPI(
    title="9 Rocks Tours API",
    description="API completa para gestão de tours em Portugal",
    version="2.0.0"
)

# ✅ CONFIGURAR O CORS
origins = [
    "http://localhost:3000",
    "https://9rocks.pt",
    "https://www.9rocks.pt",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# Security scheme for Firebase JWT
security = HTTPBearer(auto_error=False)

# ================================
# GOOGLE CALENDAR CONFIGURATION
# ================================
GOOGLE_CALENDAR_API_KEY = os.environ.get('GOOGLE_CALENDAR_API_KEY', '')
GOOGLE_CALENDAR_ID = os.environ.get('GOOGLE_CALENDAR_ID', '')

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ================================
# FIREBASE UTILITIES
# ================================
async def verify_firebase_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify Firebase JWT token for admin authentication"""
    if not credentials:
        return None
    
    try:
        token = credentials.credentials
        if token.startswith("temp_admin_token_"):
            return {"uid": "admin", "email": "admin@9rockstours.com"}
        return None
    except Exception:
        return None

def upload_image_to_firebase(image_data: str, filename: str) -> str:
    """Upload base64 image to Firebase Storage"""
    try:
        if image_data.startswith('data:image'):
            return image_data
        else:
            return f"data:image/jpeg;base64,{image_data}"
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to upload image: {str(e)}")

# ================================
# GOOGLE CALENDAR UTILITIES
# ================================
def get_calendar_availability(start_date: str, end_date: str) -> List[str]:
    """Get available dates from Google Calendar"""
    try:
        service = build('calendar', 'v3', developerKey=GOOGLE_CALENDAR_API_KEY)
        events_result = service.events().list(
            calendarId=GOOGLE_CALENDAR_ID,
            timeMin=f"{start_date}T00:00:00Z",
            timeMax=f"{end_date}T23:59:59Z",
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        
        events = events_result.get('items', [])
        start = datetime.fromisoformat(start_date)
        end = datetime.fromisoformat(end_date)
        available_dates = []
        current = start
        while current <= end:
            if current.weekday() < 5:
                available_dates.append(current.strftime("%Y-%m-%d"))
            current += timedelta(days=1)
        return available_dates
    except Exception:
        start = datetime.fromisoformat(start_date)
        available_dates = []
        for i in range(0, 30, 2):
            date = start + timedelta(days=i)
            if date.weekday() < 5:
                available_dates.append(date.strftime("%Y-%m-%d"))
        return available_dates

# ================================
# BOOKING MODELS
# ================================
class BookingCreate(BaseModel):
    tour_id: str
    customer_name: str
    customer_email: str
    customer_phone: str
    selected_date: str
    participants: int
    special_requests: Optional[str] = None
    payment_method: str

class BookingUpdate(BaseModel):
    status: Optional[str] = None
    payment_status: Optional[str] = None
    payment_transaction_id: Optional[str] = None

class Booking(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tour_id: str
    customer_name: str
    customer_email: str
    customer_phone: str
    selected_date: str
    participants: int
    total_amount: float
    special_requests: Optional[str] = None
    payment_method: str
    status: str = "pending"
    payment_status: str = "pending"
    payment_transaction_id: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

# ================================
# PAYMENT MODELS
# ================================
class PaymentMethod(str, Enum):
    PAYPAL = "paypal"
    GOOGLE_PAY = "google_pay"
    STRIPE_CARD = "stripe_card"
    MULTIBANCO = "multibanco"
    MBWAY = "mbway"

class PaymentRequest(BaseModel):
    amount: float
    currency: str = "EUR"
    tour_id: str
    booking_id: str
    customer_email: str
    customer_name: str
    payment_method: PaymentMethod
    return_url: str
    cancel_url: str
    phone_number: Optional[str] = None

class PaymentResponse(BaseModel):
    payment_id: str
    approval_url: Optional[str] = None
    client_secret: Optional[str] = None
    status: str
    reference: Optional[str] = None

class PaymentExecution(BaseModel):
    payer_id: str

class PaymentIntent(BaseModel):
    payment_intent_id: str

class PaymentTransaction(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    payment_id: str
    booking_id: str
    tour_id: str
    customer_email: str
    customer_name: str
    amount: float
    currency: str
    payment_method: str
    status: str
    transaction_id: Optional[str] = None
    approval_url: Optional[str] = None
    client_secret: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None

# ================================
# FIREBASE MODELS
# ================================
class ImageUpload(BaseModel):
    image_data: str
    filename: str
    tour_id: Optional[str] = None

class ImageUploadResponse(BaseModel):
    image_url: str
    filename: str
    message: str

class CalendarAvailability(BaseModel):
    start_date: str
    end_date: str

class CalendarAvailabilityResponse(BaseModel):
    available_dates: List[str]
    calendar_id: str

# ================================
# ADMIN AUTH MODEL
# ================================
class AdminLogin(BaseModel):
    username: str
    password: str

class AdminResponse(BaseModel):
    message: str
    token: Optional[str] = None

# ================================
# STATS MODELS
# ================================
class BookingStats(BaseModel):
    total_bookings: int
    total_revenue: float
    bookings_by_tour: Dict[str, int]
    bookings_by_date: Dict[str, int]
    bookings_by_status: Dict[str, int]

# ================================
# 🚀 PAYPAL ENDPOINTS
# ================================

@api_router.get("/payments/test/paypal")
async def test_paypal_connection():
    """Testar conexão PayPal"""
    if not PAYPAL_AVAILABLE or not paypal_service:
        return {
            "status": "error",
            "message": "PayPal Service não disponível",
            "mode": "N/A"
        }
    
    try:
        result = paypal_service.test_connection()
        return result
    except Exception as e:
        return {
            "status": "error",
            "message": f"Erro na conexão PayPal: {str(e)}",
            "mode": paypal_service.mode if paypal_service else "N/A"
        }

@api_router.post("/payments/paypal/create", response_model=PaymentResponse)
async def create_paypal_payment(payment_request: PaymentRequest):
    """Criar pagamento PayPal"""
    if not PAYPAL_AVAILABLE or not paypal_service:
        raise HTTPException(status_code=503, detail="PayPal não está disponível")
    
    try:
        booking_doc = db_firestore.collection('bookings').document(payment_request.booking_id).get()
        if not booking_doc.exists:
            raise HTTPException(status_code=404, detail="Reserva não encontrada")
        
        booking_data = booking_doc.to_dict()
        tour_doc = db_firestore.collection('tours').document(payment_request.tour_id).get()
        if not tour_doc.exists:
            raise HTTPException(status_code=404, detail="Tour não encontrado")
        
        tour_data = tour_doc.to_dict()
        paypal_data = {
            "amount": payment_request.amount,
            "tour_id": payment_request.tour_id,
            "tour_name": tour_data.get('name', {}).get('pt', 'Tour Portugal'),
            "booking_id": payment_request.booking_id,
            "participants": booking_data.get('participants', 1),
            "return_url": payment_request.return_url,
            "cancel_url": payment_request.cancel_url
        }
        
        payment_result = paypal_service.create_payment(paypal_data)
        transaction = PaymentTransaction(
            payment_id=payment_result["payment_id"],
            booking_id=payment_request.booking_id,
            tour_id=payment_request.tour_id,
            customer_email=payment_request.customer_email,
            customer_name=payment_request.customer_name,
            amount=payment_request.amount,
            currency="EUR",
            payment_method="paypal",
            status="created",
            approval_url=payment_result.get("approval_url")
        )
        
        transaction_dict = transaction.dict()
        db_firestore.collection('payment_transactions').document(transaction_dict['id']).set(transaction_dict)
        
        return PaymentResponse(
            payment_id=payment_result["payment_id"],
            approval_url=payment_result.get("approval_url"),
            status=payment_result["status"]
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/paypal/execute/{payment_id}")
async def execute_paypal_payment(payment_id: str, execution: PaymentExecution):
    """Executar pagamento PayPal aprovado"""
    if not PAYPAL_AVAILABLE or not paypal_service:
        raise HTTPException(status_code=503, detail="PayPal não está disponível")
    
    try:
        transaction_docs = db_firestore.collection('payment_transactions').where('payment_id', '==', payment_id).stream()
        transaction_doc = None
        for doc in transaction_docs:
            transaction_doc = doc
            break
        
        if not transaction_doc:
            raise HTTPException(status_code=404, detail="Transação não encontrada")
        
        transaction_data = transaction_doc.to_dict()
        if transaction_data.get("status") == "completed":
            return {"message": "Pagamento já processado", "status": "completed"}
        
        execution_result = paypal_service.execute_payment(payment_id, execution.payer_id)
        update_data = {
            "status": "completed",
            "transaction_id": execution_result.get("transaction_id"),
            "payer_email": execution_result.get("payer_email"),
            "payer_name": execution_result.get("payer_name"),
            "completed_at": datetime.utcnow()
        }
        
        db_firestore.collection('payment_transactions').document(transaction_doc.id).update(update_data)
        
        booking_id = transaction_data.get("booking_id")
        if booking_id:
            booking_update = {
                "payment_status": "paid",
                "status": "confirmed",
                "payment_transaction_id": execution_result.get("transaction_id"),
                "updated_at": datetime.utcnow()
            }
            db_firestore.collection('bookings').document(booking_id).update(booking_update)
        
        return execution_result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/payments/paypal/status/{payment_id}")
async def get_paypal_payment_status(payment_id: str):
    """Verificar status do pagamento PayPal"""
    if not PAYPAL_AVAILABLE or not paypal_service:
        raise HTTPException(status_code=503, detail="PayPal não está disponível")
    
    try:
        payment_details = paypal_service.get_payment_details(payment_id)
        transaction_docs = db_firestore.collection('payment_transactions').where('payment_id', '==', payment_id).stream()
        for doc in transaction_docs:
            current_data = doc.to_dict()
            if current_data.get("status") != payment_details["status"]:
                db_firestore.collection('payment_transactions').document(doc.id).update({
                    "status": payment_details["status"],
                    "updated_at": datetime.utcnow()
                })
            break
        
        return payment_details
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/webhooks/paypal")
async def paypal_webhook(request: Request):
    """Webhook PayPal"""
    try:
        body = await request.body()
        body_str = body.decode('utf-8')
        webhook_data = json.loads(body_str)
        event_type = webhook_data.get('event_type')
        
        if event_type == 'PAYMENT.SALE.COMPLETED':
            resource = webhook_data.get('resource', {})
            payment_id = resource.get('parent_payment')
            
            if payment_id:
                transaction_docs = db_firestore.collection('payment_transactions').where('payment_id', '==', payment_id).stream()
                for doc in transaction_docs:
                    db_firestore.collection('payment_transactions').document(doc.id).update({
                        "status": "completed",
                        "webhook_received_at": datetime.utcnow()
                    })
                    break
        
        return {"status": "webhook_processed"}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ================================
# 🚀 STRIPE/GOOGLE PAY ENDPOINTS
# ================================

@api_router.get("/payments/test/stripe")
async def test_stripe_connection():
    """Testar conexão Stripe"""
    if not STRIPE_AVAILABLE or not stripe_service:
        return {
            "status": "error",
            "message": "Stripe Service não disponível",
            "mode": "N/A"
        }
    
    try:
        result = stripe_service.test_connection()
        return result
    except Exception as e:
        return {
            "status": "error",
            "message": f"Erro na conexão Stripe: {str(e)}",
            "mode": stripe_service.mode if stripe_service else "N/A"
        }

@api_router.get("/payments/stripe/config")
async def get_stripe_config():
    """Configuração Stripe para frontend"""
    if not STRIPE_AVAILABLE or not stripe_service:
        raise HTTPException(status_code=503, detail="Stripe não está disponível")
    
    return {
        "publishable_key": stripe_service.get_publishable_key(),
        "merchant_id": os.getenv('GOOGLE_MERCHANT_ID'),
        "available": True,
        "mode": stripe_service.mode
    }

@api_router.post("/payments/google-pay/create-intent")
async def create_google_pay_intent(payment_request: PaymentRequest):
    """Criar Payment Intent para Google Pay"""
    if not STRIPE_AVAILABLE or not stripe_service:
        raise HTTPException(status_code=503, detail="Stripe não está disponível")
    
    try:
        booking_doc = db_firestore.collection('bookings').document(payment_request.booking_id).get()
        if not booking_doc.exists:
            raise HTTPException(status_code=404, detail="Reserva não encontrada")
        
        booking_data = booking_doc.to_dict()
        tour_doc = db_firestore.collection('tours').document(payment_request.tour_id).get()
        if not tour_doc.exists:
            raise HTTPException(status_code=404, detail="Tour não encontrado")
        
        tour_data = tour_doc.to_dict()
        stripe_data = {
            "amount": payment_request.amount,
            "tour_id": payment_request.tour_id,
            "tour_name": tour_data.get('name', {}).get('pt', 'Tour Portugal'),
            "booking_id": payment_request.booking_id,
            "participants": booking_data.get('participants', 1),
            "customer_email": payment_request.customer_email,
            "customer_name": payment_request.customer_name
        }
        
        intent_result = stripe_service.create_payment_intent(stripe_data)
        if intent_result.get("status") != "created":
            raise HTTPException(status_code=500, detail=intent_result.get("message", "Erro ao criar PaymentIntent no Stripe"))

        transaction = PaymentTransaction(
            payment_id=intent_result["payment_intent_id"],
            booking_id=payment_request.booking_id,
            tour_id=payment_request.tour_id,
            customer_email=payment_request.customer_email,
            customer_name=payment_request.customer_name,
            amount=payment_request.amount,
            currency="EUR",
            payment_method="google_pay",
            status="created",
            client_secret=intent_result["client_secret"]
        )

        transaction_dict = transaction.dict()
        db_firestore.collection('payment_transactions').document(transaction_dict['id']).set(transaction_dict)

        return {
            "client_secret": intent_result["client_secret"],
            "payment_intent_id": intent_result["payment_intent_id"],
            "status": intent_result["status"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/stripe-card/create-intent")
async def create_stripe_card_intent(payment_request: PaymentRequest):
    """Criar Payment Intent para cartão Stripe"""
    if not STRIPE_AVAILABLE or not stripe_service:
        raise HTTPException(status_code=503, detail="Stripe não está disponível")
    
    try:
        booking_doc = db_firestore.collection('bookings').document(payment_request.booking_id).get()
        if not booking_doc.exists:
            raise HTTPException(status_code=404, detail="Reserva não encontrada")
        
        booking_data = booking_doc.to_dict()
        tour_doc = db_firestore.collection('tours').document(payment_request.tour_id).get()
        if not tour_doc.exists:
            raise HTTPException(status_code=404, detail="Tour não encontrado")
        
        tour_data = tour_doc.to_dict()
        stripe_data = {
            "amount": payment_request.amount,
            "tour_id": payment_request.tour_id,
            "tour_name": tour_data.get('name', {}).get('pt', 'Tour Portugal'),
            "booking_id": payment_request.booking_id,
            "participants": booking_data.get('participants', 1),
            "customer_email": payment_request.customer_email,
            "customer_name": payment_request.customer_name
        }
        
        intent_result = stripe_service.create_payment_intent(stripe_data)
        transaction = PaymentTransaction(
            payment_id=intent_result["payment_intent_id"],
            booking_id=payment_request.booking_id,
            tour_id=payment_request.tour_id,
            customer_email=payment_request.customer_email,
            customer_name=payment_request.customer_name,
            amount=payment_request.amount,
            currency="EUR",
            payment_method="stripe_card",
            status="created",
            client_secret=intent_result["client_secret"]
        )
        
        transaction_dict = transaction.dict()
        db_firestore.collection('payment_transactions').document(transaction_dict['id']).set(transaction_dict)
        
        return {
            "client_secret": intent_result["client_secret"],
            "payment_intent_id": intent_result["payment_intent_id"],
            "status": intent_result["status"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/stripe/confirm/{payment_intent_id}")
async def confirm_stripe_payment(payment_intent_id: str):
    """Confirmar pagamento Stripe"""
    if not STRIPE_AVAILABLE or not stripe_service:
        raise HTTPException(status_code=503, detail="Stripe não está disponível")
    
    try:
        payment_result = stripe_service.confirm_payment(payment_intent_id)
        transaction_docs = db_firestore.collection('payment_transactions').where('payment_id', '==', payment_intent_id).stream()
        transaction_doc = None
        for doc in transaction_docs:
            transaction_doc = doc
            break
        
        if not transaction_doc:
            raise HTTPException(status_code=404, detail="Transação não encontrada")
        
        transaction_data = transaction_doc.to_dict()
        update_data = {
            "status": payment_result["status"],
            "transaction_id": payment_result.get("transaction_id"),
            "updated_at": datetime.utcnow()
        }
        
        if payment_result["status"] == "succeeded":
            update_data["completed_at"] = datetime.utcnow()
        
        db_firestore.collection('payment_transactions').document(transaction_doc.id).update(update_data)
        
        if payment_result["status"] == "succeeded":
            booking_id = transaction_data.get("booking_id")
            if booking_id:
                booking_update = {
                    "payment_status": "paid",
                    "status": "confirmed", 
                    "payment_transaction_id": payment_result.get("transaction_id"),
                    "updated_at": datetime.utcnow()
                }
                db_firestore.collection('bookings').document(booking_id).update(booking_update)
        
        return payment_result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/payments/stripe/status/{payment_intent_id}")
async def get_stripe_payment_status(payment_intent_id: str):
    """Verificar status Stripe"""
    if not STRIPE_AVAILABLE or not stripe_service:
        raise HTTPException(status_code=503, detail="Stripe não está disponível")
    
    try:
        payment_details = stripe_service.confirm_payment(payment_intent_id)
        transaction_docs = db_firestore.collection('payment_transactions').where('payment_id', '==', payment_intent_id).stream()
        for doc in transaction_docs:
            current_data = doc.to_dict()
            if current_data.get("status") != payment_details["status"]:
                db_firestore.collection('payment_transactions').document(doc.id).update({
                    "status": payment_details["status"],
                    "updated_at": datetime.utcnow()
                })
            break
        
        return payment_details
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ================================
# PAYMENT STATUS & ADMIN ENDPOINTS
# ================================

@api_router.get("/payments/status")
async def get_payment_methods_status():
    """Status geral dos métodos de pagamento"""
    return {
        "paypal": {
            "available": PAYPAL_AVAILABLE,
            "status": "connected" if PAYPAL_AVAILABLE else "disconnected",
            "mode": paypal_service.mode if PAYPAL_AVAILABLE else "N/A"
        },
        "stripe": {
            "available": STRIPE_AVAILABLE,
            "status": "connected" if STRIPE_AVAILABLE else "disconnected", 
            "mode": stripe_service.mode if STRIPE_AVAILABLE else "N/A"
        },
        "google_pay": {
            "available": STRIPE_AVAILABLE and bool(os.getenv('GOOGLE_MERCHANT_ID')),
            "merchant_id": os.getenv('GOOGLE_MERCHANT_ID', 'Not configured'),
            "status": "ready" if STRIPE_AVAILABLE and os.getenv('GOOGLE_MERCHANT_ID') else "not_configured"
        }
    }

@api_router.get("/admin/payments/all", dependencies=[Depends(verify_firebase_token)])
async def get_all_payments_detailed():
    """✅ Retorna todos os pagamentos com detalhes e segurança (PayPal, Stripe, Google Pay)"""
    try:
        transactions_ref = db_firestore.collection('payment_transactions')
        docs = transactions_ref.order_by('created_at', direction=firestore.Query.DESCENDING).stream()
        
        payments = []
        for doc in docs:
            data = doc.to_dict()
            data['id'] = doc.id
            
            if 'created_at' in data and data['created_at']:
                data['created_at'] = data['created_at'].isoformat() if hasattr(data['created_at'], 'isoformat') else str(data['created_at'])
            
            if 'completed_at' in data and data['completed_at']:
                data['completed_at'] = data['completed_at'].isoformat() if hasattr(data['completed_at'], 'isoformat') else str(data['completed_at'])
            
            if 'updated_at' in data and data['updated_at']:
                data['updated_at'] = data['updated_at'].isoformat() if hasattr(data['updated_at'], 'isoformat') else str(data['updated_at'])
            
            payments.append(data)
        
        return {
            "success": True,
            "payments": payments,
            "total": len(payments),
            "summary": {
                "paypal": len([p for p in payments if p.get('payment_method') == 'paypal']),
                "google_pay": len([p for p in payments if p.get('payment_method') == 'google_pay']),
                "stripe_card": len([p for p in payments if p.get('payment_method') == 'stripe_card']),
                "completed": len([p for p in payments if p.get('status') in ['completed', 'succeeded']]),
                "pending": len([p for p in payments if p.get('status') in ['created', 'pending']]),
                "failed": len([p for p in payments if p.get('status') in ['failed', 'cancelled']])
            },
            "last_updated": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        print(f"❌ Erro ao carregar pagamentos detalhados: {e}")
        raise HTTPException(status_code=500, detail=f"Erro ao carregar pagamentos: {str(e)}")

# ================================
# BOOKING API ENDPOINTS
# ================================
@api_router.post("/bookings", response_model=Booking)
async def create_booking(booking_data: BookingCreate):
    """Create a new booking"""
    try:
        tour_doc_ref = db_firestore.collection('tours').document(booking_data.tour_id)
        tour_doc = tour_doc_ref.get()
        if not tour_doc.exists or not tour_doc.to_dict().get('active'):
            raise HTTPException(status_code=404, detail="Tour not found or inactive")
        tour = tour_doc.to_dict()
        
        tour_availability = tour.get("availability_dates", [])
        if not tour_availability:
            tour_availability = [(datetime.now() + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(30)]

        if booking_data.selected_date not in tour_availability:
            raise HTTPException(status_code=400, detail="Selected date is not available")
            
        total_amount = tour["price"] * booking_data.participants
        booking = Booking(**booking_data.dict(), total_amount=total_amount)
        booking_dict = booking.dict()
        booking_id = booking_dict['id']
        db_firestore.collection('bookings').document(booking_id).set(booking_dict)
        
        return booking
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@api_router.get("/bookings", response_model=List[Booking])
async def get_bookings(
    status: Optional[str] = Query(None, description="Filter by booking status"),
    tour_id: Optional[str] = Query(None, description="Filter by tour ID"),
    customer_email: Optional[str] = Query(None, description="Filter by customer email")
):
    """Get all bookings with filters"""
    try:
        query = db_firestore.collection('bookings')
        if status:
            query = query.where('status', '==', status)
        if tour_id:
            query = query.where('tour_id', '==', tour_id)
        if customer_email:
            query = query.where('customer_email', '==', customer_email)
        docs = query.stream()
        bookings_list = []
        for doc in docs:
            booking_data = doc.to_dict()
            booking_data['id'] = doc.id
            bookings_list.append(Booking(**booking_data))
        return bookings_list
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/bookings/{booking_id}", response_model=Booking)
async def get_booking(booking_id: str):
    """Get specific booking by ID"""
    try:
        doc = db_firestore.collection('bookings').document(booking_id).get()
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Booking not found")
        booking_data = doc.to_dict()
        booking_data['id'] = doc.id
        return Booking(**booking_data)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ================================
# ADMIN AUTH ENDPOINTS
# ================================
@api_router.post("/admin/login", response_model=AdminResponse)
async def admin_login(credentials: AdminLogin):
    """Admin login"""
    if credentials.username == "admin" and credentials.password == "9rocks2025":
        return AdminResponse(
            message="Login successful",
            token="temp_admin_token_" + str(uuid.uuid4())
        )
    else:
        raise HTTPException(status_code=401, detail="Invalid credentials")

# ================================
# STATISTICS ENDPOINTS
# ================================
@api_router.get("/admin/stats", response_model=BookingStats)
async def get_booking_stats():
    """Get booking statistics"""
    try:
        docs = db_firestore.collection('bookings').stream()
        bookings = [doc.to_dict() for doc in docs]
        total_bookings = len(bookings)
        total_revenue = sum(booking.get("total_amount", 0) for booking in bookings)
        bookings_by_tour = {}
        for booking in bookings:
            tour_id = booking.get("tour_id")
            bookings_by_tour[tour_id] = bookings_by_tour.get(tour_id, 0) + 1
        bookings_by_date = {}
        for booking in bookings:
            date_str = booking.get("selected_date", "")[:10]
            bookings_by_date[date_str] = bookings_by_date.get(date_str, 0) + 1
        bookings_by_status = {}
        for booking in bookings:
            status = booking.get("status", "unknown")
            bookings_by_status[status] = bookings_by_status.get(status, 0) + 1
        return BookingStats(
            total_bookings=total_bookings,
            total_revenue=total_revenue,
            bookings_by_tour=bookings_by_tour,
            bookings_by_date=bookings_by_date,
            bookings_by_status=bookings_by_status
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ================================
# FIREBASE ENDPOINTS
# ================================
@api_router.post("/admin/upload-image", response_model=ImageUploadResponse)
async def upload_tour_image(image_upload: ImageUpload, user=Depends(verify_firebase_token)):
    """Upload image to Firebase Storage"""
    if not user:
        raise HTTPException(status_code=401, detail="Authentication required")
    try:
        image_url = upload_image_to_firebase(image_upload.image_data, image_upload.filename)
        if image_upload.tour_id:
            doc = db_firestore.collection('tours').document(image_upload.tour_id).get()
            if doc.exists:
                tour = doc.to_dict()
                images = tour.get("images", [])
                images.append(image_url)
                db_firestore.collection('tours').document(image_upload.tour_id).update({
                    "images": images,
                    "updated_at": datetime.utcnow()
                })
        return ImageUploadResponse(
            image_url=image_url,
            filename=image_upload.filename,
            message="Image uploaded successfully"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/firebase-config")
async def get_firebase_config():
    """Get Firebase configuration for frontend"""
    return {
        "apiKey": os.environ.get('FIREBASE_API_KEY', ''),
        "authDomain": os.environ.get('FIREBASE_AUTH_DOMAIN', ''),
        "projectId": os.environ.get('FIREBASE_PROJECT_ID', ''),
        "storageBucket": os.environ.get('FIREBASE_STORAGE_BUCKET', ''),
        "messagingSenderId": os.environ.get('FIREBASE_MESSAGING_SENDER_ID', ''),
        "appId": os.environ.get('FIREBASE_APP_ID', '')
    }

# ================================
# TEST ENDPOINTS
# ================================
@api_router.get("/")
async def root():
    return {
        "message": "9 Rocks Tours API - Ready!",
        "paypal_status": "available" if PAYPAL_AVAILABLE else "unavailable",
        "stripe_status": "available" if STRIPE_AVAILABLE else "unavailable",
        "google_pay_status": "ready" if STRIPE_AVAILABLE and os.getenv('GOOGLE_MERCHANT_ID') else "not_ready",
        "version": "2.0.0"
    }

@api_router.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "2.0.0",
        "firebase_status": "connected" if db_firestore else "disconnected",
        "paypal_status": "available" if PAYPAL_AVAILABLE else "unavailable",
        "stripe_status": "available" if STRIPE_AVAILABLE else "unavailable",
        "google_pay_ready": bool(STRIPE_AVAILABLE and os.getenv('GOOGLE_MERCHANT_ID'))
    }

# ===================================================================
# ✅ ENDPOINTS DE CONFIGURAÇÃO CORRIGIDOS
# ===================================================================

@api_router.get("/config/tour-filters")
async def get_tour_filters_config():
    """Retorna os filtros de tours ativos do Firestore de forma segura."""
    try:
        filters_ref = db_firestore.collection('tourFilters')
        docs = filters_ref.where('active', '==', True).stream()
        
        filters_list = []
        for doc in docs:
            filter_data = doc.to_dict()
            filter_data['key'] = doc.id
            filters_list.append(filter_data)
        
        filters_list.sort(key=lambda x: x.get('order', 99))
            
        return filters_list
    except Exception as e:
        print(f"❌ Erro ao buscar filtros de tours: {e}")
        raise HTTPException(status_code=500, detail=f"Erro ao buscar filtros: {str(e)}")

@api_router.get("/config/hero-images")
async def get_hero_images_config():
    """Retorna as imagens de herói ativas do Firestore de forma segura."""
    try:
        images_ref = db_firestore.collection('heroImages')
        docs = images_ref.where('active', '==', True).stream()
        
        images_list = []
        for doc in docs:
            image_data = doc.to_dict()
            image_data['id'] = doc.id
            images_list.append(image_data)
        
        images_list.sort(key=lambda x: x.get('order', 99))
            
        return images_list
    except Exception as e:
        print(f"❌ Erro ao buscar imagens de herói: {e}")
        raise HTTPException(status_code=500, detail=f"Erro ao buscar imagens: {str(e)}")


# ===================================================================
# ✅ ENDPOINT DE DEBUG (APENAS EM MODO DE DESENVOLVIMENTO)
# ===================================================================
if os.getenv("DEBUG", "False").lower() == "true":
    @api_router.get("/debug/routes", include_in_schema=False)
    async def list_routes_api():
        """Lista todas as rotas registadas na aplicação (apenas para debug)."""
        from fastapi.routing import APIRoute
        routes = []
        for route in app.routes:
            if isinstance(route, APIRoute) and route.path.startswith("/api"):
                routes.append({
                    "path": route.path,
                    "name": route.name,
                    "methods": sorted(list(route.methods)),
                })
        return {"routes": sorted(routes, key=lambda x: x["path"])}

# ================================
# APP CONFIGURATION FINAL
# ================================
api_router.include_router(
    tours_router.router,
    prefix="/tours",
    tags=["Tours"],
    include_in_schema=True
)
app.include_router(api_router)

# Configurar SEO routes
try:
    app = setup_seo_routes(app)
except Exception as e:
    print(f"❌ Erro ao configurar rotas de SEO: {e}")


@app.get("/")
async def read_root():
    return {
        "message": "9 Rocks Tours API is running", 
        "status": "healthy",
        "paypal": "available" if PAYPAL_AVAILABLE else "unavailable",
        "stripe": "available" if STRIPE_AVAILABLE else "unavailable",
        "google_pay": "ready" if STRIPE_AVAILABLE and os.getenv('GOOGLE_MERCHANT_ID') else "not_ready"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
